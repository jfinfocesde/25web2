# Tutorial: Zustand con Next.js y TypeScript

Este tutorial explica cómo integrar **Zustand**, una librería ligera de gestión de estado, en un proyecto **Next.js** con **TypeScript**. También incluye una comparación entre **Zustand** y **useContext** para ayudarte a elegir la mejor herramienta para tu proyecto. Usaremos un ejemplo simple de un **contador** para ilustrar la implementación.

!!! info "Prerrequisitos"
    - Node.js (versión 18 o superior).
    - Conocimientos básicos de React y TypeScript.

## Configuración del Proyecto

### Paso 1: Crear un Proyecto Next.js

Crea un nuevo proyecto Next.js con soporte para TypeScript y Tailwind CSS:

```bash
npx create-next-app@latest mi-app-zustand --typescript --tailwind --eslint --app --src-dir
cd mi-app-zustand
```

!!! note
    - `--typescript`: Habilita TypeScript.
    - `--tailwind`: Agrega Tailwind CSS (opcional).
    - `--eslint`: Incluye ESLint.
    - `--app`: Usa el App Router.
    - `--src-dir`: Organiza el código en una carpeta `src/`.

### Paso 2: Instalar Zustand

Instala Zustand como dependencia:

```bash
npm install zustand
```

Zustand es ligero (~2KB) y tiene excelente soporte para TypeScript.

## Crear el Store de Zustand

### Paso 3: Definir el Store

Crea una carpeta `stores` en `src/` y un archivo `counterStore.ts`:

```typescript
// src/stores/counterStore.ts
import { create } from 'zustand';

interface CounterState {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
}

export const useCounterStore = create<CounterState>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
}));
```

!!! note
    - `create<CounterState>`: Define el estado y acciones con tipos TypeScript.
    - `set`: Actualiza el estado de forma inmutable.

## Crear un Componente Cliente

### Paso 4: Componente con Zustand

Crea un componente cliente en `src/components/Counter.tsx` (los hooks requieren `'use client'` en Next.js):

```typescript
// src/components/Counter.tsx
'use client';

import { useCounterStore } from '@/stores/counterStore';

export default function Counter() {
  const { count, increment, decrement, reset } = useCounterStore();

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100">
      <h1 className="text-4xl font-bold mb-4">Contador con Zustand</h1>
      <p className="text-6xl mb-6">{count}</p>
      <div className="space-x-4">
        <button
          onClick={increment}
          className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
        >
          +1
        </button>
        <button
          onClick={decrement}
          className="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded"
        >
          -1
        </button>
        <button
          onClick={reset}
          className="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded"
        >
          Reset
        </button>
      </div>
    </div>
  );
}
```

!!! note
    - `'use client'`: Necesario para usar hooks en Next.js.
    - Tailwind CSS se usa para estilos rápidos.

### Paso 5: Usar el Componente en una Página

Edita `src/app/page.tsx` para mostrar el contador:

```typescript
// src/app/page.tsx
import Counter from '@/components/Counter';

export default function Home() {
  return <Counter />;
}
```

### Paso 6: Ejecutar el Proyecto

Inicia el servidor de desarrollo:

```bash
npm run dev
```

Abre `http://localhost:3000` en tu navegador para ver el contador funcionando.

## Comparación: Zustand vs useContext

### ¿Qué son?

- **Zustand**: Librería ligera (~2KB) para estado global basado en stores. Similar a Redux, pero con menos boilerplate.
- **useContext**: API nativa de React para compartir estado entre componentes, combinada con `useState` o `useReducer`.

### Ejemplo con useContext

Para comparar, aquí está el mismo contador usando `useContext` con `useState`:

```typescript
// src/context/CounterContext.tsx
import { createContext, useContext, useState, ReactNode } from 'react';

interface CounterContextType {
  count: number;
  increment: () => void;
}

const CounterContext = createContext<CounterContextType | undefined>(undefined);

export function CounterProvider({ children }: { children: ReactNode }) {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);

  return (
    <CounterContext.Provider value={{ count, increment }}>
      {children}
    </CounterContext.Provider>
  );
}

export function useCounter() {
  const context = useContext(CounterContext);
  if (!context) throw new Error('useCounter debe usarse dentro de CounterProvider');
  return context;
}

// src/components/Counter.tsx
'use client';

import { useCounter } from '@/context/CounterContext';

function Counter() {
  const { count, increment } = useCounter();
  return (
    <div>
      <p>Contador: {count}</p>
      <button onClick={increment}>+1</button>
    </div>
  );
}

// src/app/page.tsx
import { CounterProvider } from '@/context/CounterContext';
import Counter from '@/components/Counter';

export default function App() {
  return (
    <CounterProvider>
      <Counter />
    </CounterProvider>
  );
}
```

### Comparación Detallada

| Aspecto                | Zustand                                   | useContext (con useState/useReducer)         |
|------------------------|-------------------------------------------|---------------------------------------------|
| **Complejidad**        | Simple, API minimalista.                  | Más complejo para estados grandes.          |
| **Boilerplate**        | Mínimo, un solo store.                    | Requiere Context, Provider y hooks.         |
| **Rendimiento**        | Solo re-renderiza componentes suscritos.  | Puede causar re-renderizados innecesarios.  |
| **TypeScript**         | Tipos inferidos automáticamente.          | Tipos manuales para el contexto.            |
| **Escalabilidad**      | Ideal para apps medianas/grandes.         | Mejor para apps pequeñas.                   |
| **Persistencia**       | Middleware (ej: localStorage).            | Soluciones manuales.                        |
| **Dependencias**       | Requiere `zustand`.                       | Nativo de React.                            |

### Ventajas y Desventajas

**Zustand**:
- **Ventajas**:
  - Menos código y más simple.
  - Evita re-renderizados innecesarios.
  - Middleware para persistencia y debugging.
  - Escalable con múltiples stores.
- **Desventajas**:
  - Dependencia externa.
  - Curva de aprendizaje inicial.

**useContext**:
- **Ventajas**:
  - Nativo, sin dependencias.
  - Ideal para estados simples (ej: temas).
  - Flexible con `useReducer`.
- **Desventajas**:
  - Más código para configurar.
  - Puede causar re-renderizados si no se optimiza.
  - Difícil de escalar en apps grandes.

### Cuándo Usar Cada Uno

- **Zustand**:
  - Apps medianas/grandes con estados complejos.
  - Necesitas rendimiento optimizado.
  - Quieres middleware (persistencia, devtools).
  - Ejemplo: Carrito de compras, autenticación.

- **useContext**:
  - Apps pequeñas con estados simples.
  - Sin dependencias externas.
  - Ejemplo: Tema claro/oscuro, formularios.
